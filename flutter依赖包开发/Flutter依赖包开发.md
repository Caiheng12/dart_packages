# Flutter Package 
## 目录
1. Flutter依赖包的简介.
3. Dart Package开发。
4. mobile2.0中目前主要使用的dart package,以及他们的主要作用。
5. Flutter Plugin开发。
6. mobile2.0中目前主要使用的插件,以及它们的主要作用。
7. 插件的通信原理
8. 怎么将dart包和插件发布到官方pub上。
9. 插件和包的几种集成方式,以及使用场景介绍。
10. 参考文档

## Flutter依赖包的简介
- 它属于一个单独的功能模块,可以同其它语言一样,如C++的dll,iOS使用的framework,android使用的jar包,npm包,等等这些都属于一种外置的依赖包,他们作为一个独立的工程模块可以在多个应用中使用,flutter也是一样,官方也提供了相应的依赖包,需在flutter工程内的`pubspec.yaml`添加相应的依赖包的配置文件引入。

- 从依赖包的结构上划分,Flutter总共有2种外置的依赖包.分别是`dart package`和`plugin package`, 其中`dart package`采用纯dart语言进行开发,他只包含flutter平台的代码。`plugin package`包含了三个平台代码,分别是`flutter`,`Android`,`iOS`,所以下开发插件包之前我们需要具备一些移动端的基础的知识,这里推荐几个传送门。
[awesome-ios](https://github.com/vsouza/awesome-ios)
[iOS官网](https://developer.apple.com/)
[Android-Tips](https://github.com/tangqi92/Android-Tips)
[Android官网](https://developer.android.google.cn/)

- 下面开始本章节的具体内容,先给自己定一个小目标,开发一个简单的`dart package`并集成到Demo中.在做demo之前请确保你的电脑已经安装好了`Flutter`、`Android`、`iOS`开发环境。

## Dart Package开发。
- step1: 创建包,可以通过命令创建和使用IDE工具创建。
  - 代码创建方式如下: 
    - `flutter create --template=package [your package name]` 
  - 通过Android Studio工具的图形化命令创建。
    ![1_create_flutter_project](1_create_flutter_project)
    ![2_create_flutter_package](2_create_flutter_package)
  - 需要注意`包名需使用英文小写`,可以使用`_`分开.如`caculator_package`

- step2: 创建完成后,进入到创建的工程目录中.
  - 可以看到系统生成了如下的目录结构文件
```tree
├── CHANGELOG.md
├── LICENSE
├── README.md
├── caculator_package.iml
├── lib
│   └── caculator_package.dart
├── pubspec.lock
├── pubspec.yaml
└── test
    └── caculator_package_test.dart
```
  - 其中`caculator_package.iml`为IDE创建的模块应用文件,包含了`dart package`的build的相关信息。
  - lib/caculator_package.dart为`dart package`对外暴露的入口文件,在lib文件下新建一个`src`文件夹用于存放我们的开发代码。
  - `pubspec.yaml`用于设置`dart package`的外置依赖,如使用的flutter的sdk版本。
   ```yaml
   name: caculator_package
description: A new Flutter package project.
version: 0.0.1
author:  wuming<wuming@163.com>  # your name<your eamil>
homepage: https://yourpackagerepourl/yourpackagename.git
environment:  #所需要的flutter sdk的版本
  sdk: ">=2.1.0 <3.0.0"
dependencies: #dart package的依赖包。我们可以在下面继续添加其它的依赖包
  flutter:
    sdk: flutter
 # url_launch: 0.0.1 #我们可以在下面继续添加其它的依赖包
dev_dependencies:
  flutter_test:
    sdk: flutter
# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec
# The following section is specific to Flutter.
flutter:
  # To add assets to your package, add an assets section, like this:
  # assets:
  #  - images/a_dot_burr.jpeg
  #  - images/a_dot_ham.jpeg
  #
  # For details regarding assets in packages, see
  # https://flutter.dev/assets-and-images/#from-packages
  #
  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/assets-and-images/#resolution-aware.
  # To add custom fonts to your package, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts in packages, see
  # https://flutter.dev/custom-fonts/#from-packages
   ```
  - `pubspec.lock`文件,用于锁定和解析`pubspec.yaml`的信息,获取当前`dart package`的依赖包。
  ```yaml
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  async:
    dependency: transitive
    description:
      name: async
      url: "https://pub.flutter-io.cn"
    source: hosted
    version: "2.3.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      url: "https://pub.flutter-io.cn"
  ```
  - `test`为该`dart package`存放测试代码的地方.
  step3: 开始编写`dart package`的具体代码实现
  - 首先在`lib`目录下新建一个`src`文件夹.然后新建一个`caculator.dart`的文件用于写计算相关的代码
  ```dart
part of caculator_package;
/// A Calculator.
class Calculator {
  /// Returns [value] plus 1.
  int addOne(int value) => value + 1;
}
  ```
  
  - 在`lib/caculator_package.dart`文件中使用`library [package name]定义`该`dart package`的名字.
  - 在`lib/src/caculator.dart`文件中`part of [package name]`表示该文件属于package的一部分,
  - 在`src/caculator_package.dart`文件中使用`part 'src/caculator'`将文件与库关联在一起。
  - 这里用到了几个系统的关键字`part of [pacakge name]` 和 `part [source file path]`需配套使用。
  step4: 编写对应测试unit
  - 进入到`test`文件夹中,编写测试代码,以`function`为单位,如果有`case`或者`if else`的分支则需将test case再进行细分.
  step4: 创建一个demo工程用于
  - 这里和创建包类似,同样可以使用`Android Studio`或`flutter command`创建,这里使用命令创建。
  - 终端运行`flutter create --template=app package_demo`,也可以直接使用`flutter create package_demo`创建。
  	```yaml
├── README.md
├── android
├── ios
├── lib
├── package_demo.iml
├── pubspec.lock
├── pubspec.yaml
└── test
  	```
  step5: 这里先介绍通过本地路径引入我们前面开发的`caculator_package`到`package_demo`工程中.
  - 将我们`caculator_package`拷贝到该demo工程的目录下.这里我新建了一个tools文件夹.
  step6: 进入到`pubspec.yaml`文件中,引入该包。
  ```yaml
dependencies:
  flutter:
    sdk: flutter
  # method1: 通过path引入
  caculator_package:    
    path: ./tools/caculator_package
  # method2: 通过git引入
  #caculator_package:    
  #  git: 
  #    url: https://yourgitrepodomain/yourpackagename.git
  #    ref: v0.0.1 #可以是分支名,也可以是tag,默认也可以省略ref
  # method3: 通过pub引入,需要我们将该包发布到pub上
  # caculator_package: ^0.0.1
  ```
  step7: 设置完`pubspec.yaml`之后,需要从新更新工程的依赖包
  - 执行`flutter package get`更新依赖包。
  - 下载完成后依赖包会出现在工程中的`dependency`栏目下.如图,我使用的是VSCode,界面如下:
  ![3_package_dependency](3_package_dependency)
  step8: 到这一步我们就已经把创建的package成功的集成到我们的demo工程中了,下面可以愉快的进行开发了。
  - 在`lib/main.dart`中导入`import 'package:caculator_package/caculator_package.dart';`
  - 使用package定义的function
  ```yaml
class _MyHomePageState extends State<MyHomePage> {
  int _counter = 0;
  Calculator _caculator = Calculator();
  void _incrementCounter() {
    setState(() {
      // This call to setState tells the Flutter framework that something has
      // changed in this State, which causes it to rerun the build method below
      // so that the display can reflect the updated values. If we changed
      // _counter without calling setState(), then the build method would not be
      // called again, and so nothing would appear to happen.
      _counter = _caculator.addOne(_counter);
    });
  }
  ```
  step8: 运行我们的demo工程,点击加号按钮,可以看到数字增加,说明我们的dart包成功运行了。
  - 附上一张效果图:
  ![4_pacakge_result_ui](4_pacakge_result_ui)

 ## 目前项目中使用的package有哪些?
  - 按照功能来划分目前主要有以下几类。
   - genernal
  ```yaml
├── china_features
│   ├── coopers
│   └── discover_feature
├── interceptors
│   ├── common_header_interceptor
│   └── refresh_token_interceptor
├── omc_api_client
├── repositories
│   ├── destination_repository
│   ├── legal_document_repository
│   ├── store_review_repository
│   ├── user_repository
│   ├── vehicle_mapping_repository
│   └── vehicle_repository
├── standard_models
├── storage
│   ├── store_review_storage
│   ├── token_storage
│   ├── user_storage
│   └── vehicle_storage
├── startup_configuration  #配置项目的运行环境
├── connected_ui
├── bloc
├── hydrated_bloc    #缓存bloc的状态信息,用于日志记录,debug调试用。
├── flutter_bloc     
├── json_annotation  #json数据解析
```

## Flutter Plugin开发
- 目前flutter的生态环境不够完善,官方发的插件库无法覆盖我们所有的业务需求,比如`地图`,`支付`,`音视频`,对国内一些大厂的三方`SDK`支持不够友好,所以在实际开发中可能需要自己开发对应的插件.下面以获取设备信息为例,来创建一个简单的插件.

- step1: 首先创建插件项目.
  - 这里选择使用代码创建,同样也可以使用`Android Studio`创建,同创建`dart package`类似。
  - `flutter create --template=plugin -i objc -a java batterylevel`,具体参数含义可以在终端通过 flutter help查看,下面是其中几个需要经常用到的参数.
  ```help
-t, --template=<type>          Specify the type of project to create.
          [app]                (default) Generate a Flutter application.
          [package]            Generate a shareable Flutter project containing
                               modular Dart code.
          [plugin]             Generate a shareable Flutter project containing
                               an API in Dart code with a platform-specific
                               implementation for Android, for iOS code, or for
                               both.
-i, --ios-language             [objc, swift (default)]
-a, --android-language         [java, kotlin (default)]
    --[no-]androidx            Generate a project using the AndroidX support
                               libraries
  ```
- step2: 进入到工程目录,首先熟悉各个文件的作用
  ```tree 
├── CHANGELOG.md
├── LICENSE
├── README.md
├── android           #编写插件`android`平台的代码
├── batterylevel.iml. #插件的模块的工程配置信息
├── example           #编写插件`iOS`平台和`android`平台的实例代码,用于做demo展示
├── ios               #编写插件`iOS`平台的代码
├── lib               #编写插件`Flutter`平台的代码
├── pubspec.lock.     #用于锁定yaml文件解析的配置信息,执行pub get时会从此文件去下载对应的依赖包
├── pubspec.yaml      #插件模块的依赖包和资源文件配置信息
└── test              #插件模块的测试代码文件夹
  ```
 - step3: 首先编写android端的代码,在`Android Studio`中打开`batterylevel`插件中,找到下面这个文件夹。
      ![5_plugin_android_src](5_plugin_android_src)
   - 在`project`模式下我们无法浏览到`src.main`中的文件,需要切换成`Android`的编辑模式.
      ![6_plugin_android_src_edit](6_plugin_android_src_edit)
   - 切换之后可以到如下三个`target`,最上面一个`batterylevel`和我们创建的插件名字一样,他是`flutter target`,然后是`batterylevel_android`是插件对应的`android`端的代码,最后一个是`battery_example_android`他是用于调试此插件的demo工程.
   - 按如图所示,设置`batterylevel_android`和`battery_example_android` target的 sdk版本,这样就不会有编译警告了。
      ![7_plugin_android_content](7_plugin_android_content)
   - 首先进入到`BatterylevelPlugin`中,编写`android`端获取设备电量信息的详细代码
   ```java
     private int getBatteryLevel() {
    int batteryLevel = -1;
    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {
      BatteryManager batteryManager = (BatteryManager) applicationContext.getSystemService(applicationContext.BATTERY_SERVICE);
      batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);
    } else {
      Intent intent = new ContextWrapper(applicationContext).
              registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
      batteryLevel = (intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100) /
              intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
    }
    return batteryLevel;
  }
   ```
   - 然后进入到flutter工程中

## Android端插件的运行流程
   1. 首先Android应用启动后会进入到`MainActivity`的`onCreate`方法中,
   2. 然后开始调用`GeneratedPluginRegistrant`的`registerWith`方法,开始注册插件.这个类是系统自动生成的一个中间类,便于管理.传入参数为当前的`MainActivity`用于和插件做数据交互。
      ```java
      public class MainActivity extends FlutterActivity {
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    //Step1: 全局插件的入口注册(这只是一个抽象类,用于集中管理多个插件的注册),在`anroid`应用的程序入口注册flutter插件.
    GeneratedPluginRegistrant.registerWith(this);
  }
}
      ```
   3. `GeneratedPluginRegistrant`的主要作用就是为各个插件管理提供一个统一的注册入口, 因为一个项目会有多个插件,为了便于统一管理,系统每次都会生成此中间类。
    ```java
    public final class GeneratedPluginRegistrant {
  public static void registerWith(PluginRegistry registry) {
    if (alreadyRegisteredWith(registry)) {
      return;
    }
    PluginA.registerWith("xxxxx");
    PluginB.registrarFor("com.example.amap_atlas.AmapAtlasPlugin"));
    .....
  }
    ```
   4. 接下来进入到我们的其中一个插件`BatterylevelPlugin`,进到插件的具体实现方法中,每个插件中至少需要绑定一个MethodChannel.如果是需要传递视图的插件,还需要注册对应的PlatformViewFactory实例.
   ```java
  public static void registerWith(Registrar registrar) {
      //step1: 注册MethodChannel用于和flutter通信, `registrar.messenger()`为MainActivity中绑定的BannaryMessager,name为对应的渠道标示。
    final MethodChannel battery_channel = new MethodChannel(registrar.messenger(), "batterylevel_channel");
    //保存activity的currentContext实例,用于获取batteryManager
    applicationContext = registrar.context();
      //step2: 绑定battery_channel的回调方法
      battery_channel.setMethodCallHandler(new BatterylevelPlugin());
      //step3: 注册ViewFactory,用于接受来自flutter端的构造视图的指令
    registrar.platformViewRegistry().registerViewFactory("batterylevel_view", new AndroidViewFactory(registrar, registrar.messenger()));
  }
   ```
   5. 上面创建的`AndroidViewFactory`必须遵守`PlatformViewFactory`定义的方法.
   ```java
    super(StandardMessageCodec.INSTANCE);
        this._registrar = registrar;
        this._binaryMessenger = binaryMessenger;
    }
    @Override
    public PlatformView create(Context context, int i, Object o) {
        return new AndroidViewDemo(i,_binaryMessenger, _registrar,o);
    }
   ```
   6. 视图的MethodChannel需要单独创建,这是因为flutter每次调用native生成视图的方法时,都会自动生成一个viewId,为了保证methodChannel和视图对应,所以需要生成对应id的methodChannel.
   ```java
     public AndroidViewDemo(int viewId,
                       BinaryMessenger messenger,
                       Registrar registrar,
                       Object o) {
        this.binaryMessenger = messenger;
        this.methodChannel = new MethodChannel(binaryMessenger, Constant.PLUGIN_BASIC_NAME + "_" + viewId);
        this.methodChannel.setMethodCallHandler(this);
        this.eventChannel =  new EventChannel(binaryMessenger, Constant.PLUGIN_BASIC_NAME + "_event_" + viewId);
        this.eventChannel.setStreamHandler(this);
        setupViews(registrar);
    }
   ```

## iOS端插件的运行流程

   ## Flutter参考资料
   1. [awesome-flutter](https://github.com/Solido/awesome-flutter)
